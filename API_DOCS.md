# GooglePay API Documentation

This document provides detailed information about the GooglePay library's API interfaces, parameter descriptions, and usage in different scenarios.

## 1. Initialization

Initialize `GooglePayClient` in the `onCreate` method of your `Application` class.

```kotlin
class App : Application(), GooglePayService {

    override fun onCreate() {
        super.onCreate()
        // Initialize GooglePayClient
        GooglePayClient.getInstance()
            .initBillingClient(this, this) // Pass Application Context and GooglePayService implementation
            .setDebug(true) // Enable debug mode with logging
            .setSubscription(false) // Whether to support subscriptions, default is false
            .setSubscriptionMode(SubscriptionMode.MultiModal) // Set subscription mode
            .setInterval(15) // Set auto-refresh interval (seconds), default is 15 seconds
            .registerActivitys(listOf(MainActivity::class.java)) // Register activities that trigger auto-refresh
    }

    // Implement GooglePayService interface methods...
}
```

## 2. Core Classes and Interfaces

### 2.1 GooglePayClient

`GooglePayClient` is the core entry point of the library, implemented as a singleton.

* **getInstance()**: Get the singleton instance.
* **initBillingClient(context: Application, service: GooglePayService)**: Initialize the client.
* **setDebug(isDebug: Boolean)**: Enable or disable debug logging.
* **setSubscription(isSubscription: Boolean)**: Enable or disable subscription support.
* **setSubscriptionMode(mode: SubscriptionMode)**: Set the subscription mode.
* **setInterval(interval: Int)**: Set the minimum time interval (in seconds) for triggering purchase status refresh when specified Activities `onResume`, default is 15 seconds.
* **registerActivitys(activitys: List&lt;Class&lt;out Activity&gt;&gt;)**: Register Activity classes that trigger auto-refresh. When these Activities `onResume` and the time since last refresh exceeds `interval`, `queryPurchases()` will be called automatically.
* **getPayService&lt;T&gt;()**: Get specific payment service (`OneTimeService` or `SubscriptionService`).
* **queryPurchases()**: Query and refresh current purchase status (including one-time products and subscriptions).
* **isGoogleAvailable(context: Context?)**: Check if Google Play services are available.
* **endConnection()**: Disconnect the BillingClient connection.

### 2.2 GooglePayService

Interface that the business layer needs to implement, used to provide product IDs and handle purchase results.

* **getOneTimeConsumableProducts()**: Return list of one-time consumable product IDs.
* **getOneTimeNonConsumableProducts()**: Return list of one-time non-consumable product IDs.
* **getSubscribeProducts()**: Return list of subscription product IDs.
* **handlePurchasesProcess(isPay: Boolean, productType: BillingProductType, purchases: Purchase)**: Handle purchase transactions, verify orders and acknowledge.

## 3. Payment Services

Obtain via `GooglePayClient.getInstance().getPayService<T>()`.

### 3.1 OneTimeService

Used to handle consumable and non-consumable products.

* **launchBillingFlow(activity: Activity, billingParams: BillingParams)**: Launch the payment flow.
* **queryProductDetails(productIds: List&lt;String&gt;)**: Query product details.

### 3.2 SubscriptionService

Used to handle subscription products.

* **launchBillingFlow(activity: Activity, billingSubsParams: BillingSubsParams)**: Launch the subscription payment flow.
* **querySubsOfferDetails(subsOfferParams: SubsOfferParams)**: Query subscription product details (including Offers).
* **queryAckSubscribePurchases(productIds: List&lt;String&gt;?)**: Query currently active subscriptions.

## 4. Parameters

### 4.1 BillingParams (One-time Purchase Parameters)

Used for `OneTimeService.launchBillingFlow`.

| Field | Type | Description |
| :--- | :--- | :--- |
| `accountId` | String | Unique user ID from business side (obfuscatedAccountId) |
| `productId` | String | Product ID configured in Google Play Console |
| `chargeNo` | String | Order number generated by business side (obfuscatedProfileId) |

**Build Example:**

```kotlin
val params = BillingParams.Builder()
    .setAccountId("user_123")
    .setProductId("coin_100")
    .setChargeNo("order_abc_456")
    .build()
```

### 4.2 BillingSubsParams (Subscription Purchase Parameters)

Used for `SubscriptionService.launchBillingFlow`.

| Field | Type | Description |
| :--- | :--- | :--- |
| `accountId` | String | Unique user ID from business side |
| `productId` | String | Subscription product ID configured in Google Play Console |
| `chargeNo` | String | Order number generated by business side |
| `offerToken` | String | Subscription offer token (obtained from `AppSubscribeDetails`) |

## 5. Payment Event Listening

`GooglePayClient` uses Kotlin Coroutines' `SharedFlow` to emit payment events.

### 5.1 BillingPayEvent

Payment event sealed class:

* `PaySuccessful(purchase: Purchase)`: Payment successful.
* `PayFailed(code: Int, message: String)`: Payment failed.
* `PayConsumeSuccessful(purchase: Purchase)`: Payment and consumption successful.
* `PayConsumeFailed(purchase: Purchase, code: Int, message: String)`: Payment successful but consumption failed.

### 5.2 Usage in Activity

It's recommended to start collecting events in `onCreate` or `onStart`, using `lifecycleScope` to ensure automatic cancellation when the lifecycle ends.

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    lifecycleScope.launch {
        // Use repeatOnLifecycle to collect only when in active state
        repeatOnLifecycle(Lifecycle.State.STARTED) {
            GooglePayClient.getInstance().appBillingPayEventFlow.collect { event ->
                when (event) {
                    is BillingPayEvent.PaySuccessful -> {
                        // Handle payment success
                        Log.d("Pay", "Success: ${event.purchase}")
                    }
                    is BillingPayEvent.PayFailed -> {
                        // Handle payment failure
                        Log.e("Pay", "Failed: ${event.code} - ${event.message}")
                    }
                    else -> {
                        // Other states
                    }
                }
            }
        }
    }
}
```

### 5.3 Usage in Dialog (Manual Release)

When listening for payment results in a `Dialog`, pay attention to coroutine scope management.

1. **Use the Activity/Fragment's lifecycleScope where the Dialog is located**: This is the recommended approach, bound to the Activity lifecycle, no manual release needed.
2. **Use custom Scope**: If you must manage within the Dialog, you need to cancel the Job in `dismiss`.

```kotlin
class PayDialog(context: Context) : Dialog(context) {
    private val dialogScope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    override fun show() {
        super.show()
        dialogScope.launch {
            GooglePayClient.getInstance().appBillingPayEventFlow.collect { event ->
                // Handle events
                if (event is BillingPayEvent.PaySuccessful) {
                    dismiss()
                }
            }
        }
    }

    override fun dismiss() {
        super.dismiss()
        // Must manually cancel to prevent memory leaks
        dialogScope.cancel()
    }
}
```

## 6. Additional Notes

1. **Lifecycle**: `GooglePayClient` internally handles Activity lifecycle awareness, but event listeners need to manage their own Scope.
2. **Consumption**: For one-time consumable products, the library automatically performs consumption operations (`consumeAsync`).
3. **Acknowledgement**: All purchases (including subscriptions) need to be acknowledged (`acknowledgePurchase`). This logic is triggered in `GooglePayService.handlePurchasesProcess` by the business layer or handled internally by the library (depending on the implementation of `handlePurchases`, the library defaults to automatically handle consumption, but acknowledgement logic usually requires business-side cooperation after verification).
