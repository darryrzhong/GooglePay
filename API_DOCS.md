# GooglePay API Documentation

This document provides detailed information about the GooglePay library's API interfaces, parameter descriptions, and usage in different scenarios.

## 1. Initialization

Initialize `GooglePayClient` in the `onCreate` method of your `Application` class.

```kotlin
class App : Application(), GooglePayService {

    override fun onCreate() {
        super.onCreate()
        // Initialize GooglePayClient
        GooglePayClient.getInstance()
            .initBillingClient(this, this) // Pass Application Context and GooglePayService implementation
            .setDebug(true) // Enable debug mode with logging
            .setSubscription(false) // Whether to support subscriptions, default is false
            .setSubscriptionMode(SubscriptionMode.MultiModal) // Set subscription mode
            .setInterval(15) // Set auto-refresh interval (seconds), default is 15 seconds
            .registerActivitys(listOf(MainActivity::class.java)) // Register activities that trigger auto-refresh
    }

    // Implement GooglePayService interface methods...
}
```

## 2. Core Classes and Interfaces

### 2.1 GooglePayClient

`GooglePayClient` is the core entry point of the library, implemented as a singleton.

* **getInstance()**: Get the singleton instance.
* **initBillingClient(context: Application, service: GooglePayService)**: Initialize the client.
* **setDebug(isDebug: Boolean)**: Enable or disable debug logging.
* **setSubscription(isSubscription: Boolean)**: Enable or disable subscription support.
* **setSubscriptionMode(mode: SubscriptionMode)**: Set the subscription mode.
* **setInterval(interval: Int)**: Set the minimum time interval (in seconds) for triggering purchase status refresh when specified Activities `onResume`, default is 15 seconds.
* **registerActivitys(activitys: List&lt;Class&lt;out Activity&gt;&gt;)**: Register Activity classes that trigger auto-refresh. When these Activities `onResume` and the time since last refresh exceeds `interval`, `queryPurchases()` will be called automatically.
* **getPayService&lt;T&gt;()**: Get specific payment service (`OneTimeService` or `SubscriptionService`).
* **queryPurchases()**: Query and refresh current purchase status (including one-time products and subscriptions).
* **isGoogleAvailable(context: Context?)**: Check if Google Play services are available.
* **endConnection()**: Disconnect the BillingClient connection.

### 2.2 GooglePayService

Interface that the business layer needs to implement, used to provide product IDs and handle purchase results.

* **getOneTimeConsumableProducts()**: Return list of one-time consumable product IDs.
* **getOneTimeNonConsumableProducts()**: Return list of one-time non-consumable product IDs.
* **getSubscribeProducts()**: Return list of subscription product IDs.
* **handlePurchasesProcess(isPay: Boolean, productType: BillingProductType, purchases: Purchase)**: Handle purchase transactions, verify orders and acknowledge.

## 3. Payment Services

Obtain via `GooglePayClient.getInstance().getPayService<T>()`.

### 3.1 OneTimeService

Used to handle consumable and non-consumable products.

* **launchBillingFlow(activity: Activity, billingParams: BillingParams)**: Launch the payment flow.
* **queryProductDetails(productIds: List&lt;String&gt;)**: Query product details.

### 3.2 SubscriptionService

Used to handle subscription products.

* **launchBillingFlow(activity: Activity, billingSubsParams: BillingSubsParams)**: Launch the subscription payment flow.
* **querySubsOfferDetails(subsOfferParams: SubsOfferParams)**: Query subscription product details (including Offers).
* **queryAckSubscribePurchases(productIds: List&lt;String&gt;?)**: Query currently active subscriptions.

## 4. Parameters

### 4.1 BillingParams (One-time Purchase Parameters)

Used for `OneTimeService.launchBillingFlow`.

| Field | Type | Description |
| :--- | :--- | :--- |
| `accountId` | String | Unique user ID from business side (obfuscatedAccountId) |
| `productId` | String | Product ID configured in Google Play Console |
| `chargeNo` | String | Order number generated by business side (obfuscatedProfileId) |

**Build Example:**

```kotlin
val params = BillingParams.Builder()
    .setAccountId("user_123")
    .setProductId("coin_100")
    .setChargeNo("order_abc_456")
    .build()
```

### 4.2 BillingSubsParams (Subscription Purchase Parameters)

Used for `SubscriptionService.launchBillingFlow`.

| Field | Type | Description |
| :--- | :--- | :--- |
| `accountId` | String | Unique user ID from business side |
| `productId` | String | Subscription product ID configured in Google Play Console |
| `chargeNo` | String | Order number generated by business side |
| `offerToken` | String | Subscription offer token (obtained from `AppSubscribeDetails`) |

### 4.3 AppBillingResponseCode (Response Codes)

`AppBillingResponseCode` defines all possible response codes returned by the Google Play Billing API.

| Code | Constant | Description |
| :--- | :--- | :--- |
| `0` | `OK` | Request successful |
| `-200` | `FAIL` | Business error |
| `-3` | `SERVICE_TIMEOUT` | Request timeout (deprecated, use `SERVICE_UNAVAILABLE` instead) |
| `-2` | `FEATURE_NOT_SUPPORTED` | Current device or Google Play does not support this feature (e.g., subscriptions, product details) |
| `-1` | `SERVICE_DISCONNECTED` | Disconnected from Google Play Billing service, can retry connection |
| `1` | `USER_CANCELED` | User actively canceled the billing flow |
| `2` | `SERVICE_UNAVAILABLE` | Network issue or Google Play service unavailable (e.g., updating, offline) |
| `3` | `BILLING_UNAVAILABLE` | Google Play Billing not supported on current device |
| `4` | `ITEM_UNAVAILABLE` | Product unavailable in current region or account (e.g., not published or delisted) |
| `5` | `DEVELOPER_ERROR` | Developer error (e.g., parameter error, incorrect API call sequence) |
| `6` | `ERROR` | General error (system internal exception, unknown issue) |
| `7` | `ITEM_ALREADY_OWNED` | Product already owned (e.g., unconsumed consumable or purchased non-consumable) |
| `8` | `ITEM_NOT_OWNED` | Operation failed because product not owned (attempting to consume or acknowledge unowned product) |
| `12` | `NETWORK_ERROR` | Network error (explicitly for network failure scenarios) |

**Usage Example:**

```kotlin
when (responseCode) {
    AppBillingResponseCode.OK -> {
        // Handle success
    }
    AppBillingResponseCode.USER_CANCELED -> {
        // User canceled payment
    }
    AppBillingResponseCode.ITEM_ALREADY_OWNED -> {
        // Product already owned
    }
    AppBillingResponseCode.NETWORK_ERROR -> {
        // Network error, can retry
    }
    else -> {
        // Handle other errors
    }
}
```

### 4.4 AppProductDetails (Product Details Model)

`AppProductDetails` represents the details of a one-time purchase product (consumable or non-consumable).

| Field | Type | Description |
| :--- | :--- | :--- |
| `productId` | String | Product ID (e.g., `com.xx.product.1`) |
| `productName` | String | Product name |
| `formattedPrice` | String | Formatted price string (e.g., `"€7.99"`) |
| `priceAmountMicros` | Long | Price in micros (e.g., if price is `"€7.99"`, this value is `7990000`) |
| `priceCurrencyCode` | String | Currency code (e.g., `"EUR"`) |

**Query Product Details Example:**

```kotlin
val oneTimeService = GooglePayClient.getInstance().getPayService<OneTimeService>()

lifecycleScope.launch {
    oneTimeService.queryProductDetails(listOf("coin_100", "coin_500")).collect { result ->
        result.onSuccess { productList ->
            productList.forEach { product ->
                Log.d("Product", "ID: ${product.productId}")
                Log.d("Product", "Name: ${product.productName}")
                Log.d("Product", "Price: ${product.formattedPrice}")
                Log.d("Product", "Currency: ${product.priceCurrencyCode}")
            }
        }
        result.onFailure { error ->
            Log.e("Product", "Query failed: ${error.message}")
        }
    }
}
```

### 4.5 AppSubscribeDetails (Subscription Details Model)

`AppSubscribeDetails` represents the details of a subscription product, including pricing phases.

| Field | Type | Description |
| :--- | :--- | :--- |
| `productId` | String | Subscription product ID (e.g., `com.xx.subscription.monthly`) |
| `productName` | String | Subscription product name |
| `pricingPhases` | List&lt;PricingPhase&gt; | List of pricing phases (supports trial periods, introductory prices, etc.) |

**PricingPhase Fields:**

| Field | Type | Description |
| :--- | :--- | :--- |
| `formattedPrice` | String | Formatted price string (e.g., `"€7.99"`) |
| `priceAmountMicros` | Long | Price in micros (e.g., if price is `"€7.99"`, this value is `7990000`) |
| `priceCurrencyCode` | String | Currency code (e.g., `"EUR"`) |

**Query Subscription Details Example:**

```kotlin
val subscriptionService = GooglePayClient.getInstance().getPayService<SubscriptionService>()

lifecycleScope.launch {
    val params = SubsOfferParams.Builder()
        .setProductIds(listOf("monthly_vip", "yearly_vip"))
        .build()
    
    subscriptionService.querySubsOfferDetails(params).collect { result ->
        result.onSuccess { subscriptionList ->
            subscriptionList.forEach { subscription ->
                Log.d("Subscription", "ID: ${subscription.productId}")
                Log.d("Subscription", "Name: ${subscription.productName}")
                subscription.pricingPhases.forEach { phase ->
                    Log.d("Subscription", "Phase Price: ${phase.formattedPrice}")
                }
            }
        }
    }
}
```

## 5. Payment Event Listening

`GooglePayClient` uses Kotlin Coroutines' `SharedFlow` to emit payment events.

### 5.1 BillingPayEvent

Payment event sealed class:

* `PaySuccessful(purchase: Purchase)`: Payment successful.
* `PayFailed(code: Int, message: String)`: Payment failed.
* `PayConsumeSuccessful(purchase: Purchase)`: Payment and consumption successful.
* `PayConsumeFailed(purchase: Purchase, code: Int, message: String)`: Payment successful but consumption failed.

### 5.2 Usage in Activity

It's recommended to start collecting events in `onCreate` or `onStart`, using `lifecycleScope` to ensure automatic cancellation when the lifecycle ends.

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    lifecycleScope.launch {
        // Use repeatOnLifecycle to collect only when in active state
        repeatOnLifecycle(Lifecycle.State.STARTED) {
            GooglePayClient.getInstance().appBillingPayEventFlow.collect { event ->
                when (event) {
                    is BillingPayEvent.PaySuccessful -> {
                        // Handle payment success
                        Log.d("Pay", "Success: ${event.purchase}")
                    }
                    is BillingPayEvent.PayFailed -> {
                        // Handle payment failure
                        Log.e("Pay", "Failed: ${event.code} - ${event.message}")
                    }
                    else -> {
                        // Other states
                    }
                }
            }
        }
    }
}
```

### 5.3 Usage in Dialog (Manual Release)

When listening for payment results in a `Dialog`, pay attention to coroutine scope management.

1. **Use the Activity/Fragment's lifecycleScope where the Dialog is located**: This is the recommended approach, bound to the Activity lifecycle, no manual release needed.
2. **Use custom Scope**: If you must manage within the Dialog, you need to cancel the Job in `dismiss`.

```kotlin
class PayDialog(context: Context) : Dialog(context) {
    private val dialogScope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    override fun show() {
        super.show()
        dialogScope.launch {
            GooglePayClient.getInstance().appBillingPayEventFlow.collect { event ->
                // Handle events
                if (event is BillingPayEvent.PaySuccessful) {
                    dismiss()
                }
            }
        }
    }

    override fun dismiss() {
        super.dismiss()
        // Must manually cancel to prevent memory leaks
        dialogScope.cancel()
    }
}
```

## 6. Additional Notes

1. **Lifecycle**: `GooglePayClient` internally handles Activity lifecycle awareness, but event listeners need to manage their own Scope.
2. **Consumption**: For one-time consumable products, the library automatically performs consumption operations (`consumeAsync`).
3. **Acknowledgement**: All purchases (including subscriptions) need to be acknowledged (`acknowledgePurchase`). This logic is triggered in `GooglePayService.handlePurchasesProcess` by the business layer or handled internally by the library (depending on the implementation of `handlePurchases`, the library defaults to automatically handle consumption, but acknowledgement logic usually requires business-side cooperation after verification).
